module ALU #(
  parameter ADDER_WIDTH = 5,
  parameter MULTIPLIER_WIDTH = 4
)(
  input logic [1:0] opcode,
  input logic [ADDER_WIDTH-1:0] a,
  input logic [MULTIPLIER_WIDTH-1:0] b,
  output logic [2*ADDER_WIDTH-1:0] result
);
  logic [ADDER_WIDTH:0] adder_out;
  logic [2*ADDER_WIDTH-1:0] multiplier_out;

  BinaryVedicAdder_4bit adder_inst (
    .A(a),
    .B(b),
    .Sum(adder_out)
  );

  Multiplier #(MULTIPLIER_WIDTH) multiplier_inst (
    .a(a),
    .b(b),
    .product(multiplier_out)
  );

  always_comb begin
    case (opcode)
      2'b00: result = adder_out;           // Addition
      2'b01: result = multiplier_out;     // Multiplication
      // Add more cases for other operations if needed
      default: result = 0;                 // Default case, no operation
    endcase
  end
endmodule

module TestALU;
  logic [1:0] opcode;
  logic [4:0] operand_a;
  logic [3:0] operand_b;
  logic [9:0] alu_result;

  ALU #(5, 4) alu_inst (
    .opcode(opcode),
    .a(operand_a),
    .b(operand_b),
    .result(alu_result)
  );

  // Add code to provide values to opcode, operand_a, and operand_b
  // and observe the alu_result

endmodule
